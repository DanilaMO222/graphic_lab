# graphic_lab
`glutInit(&argc, argv);` - инициализация GLUT
____
`glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA);` - так настраиваются некоторые опции GLUT.

GLUT_DOUBLE включает двойную буферизацию

GLUT_RGBA буфер цвета
____
`glClear(GL_COLOR_BUFFER_BIT);` - это очистка буфера кадра (используя цвет, заданный выше)
____
`glutSwapBuffers();` - функция просит GLUT поменять фоновый буфер и буфер кадра местами
____
`glGenBuffers(1, &VBO);` - функций для генерации объектов переменных типов, 
функция принимает 2 параметра:первый определяет количество объектов, которые вы хотите создать, 
и второй ссылка на массив типа GLuints для хранения указателя, по которому будут храниться данные
____
`glBindBuffer(GL_ARRAY_BUFFER, VBO);` - В OpenGL мы привязываем указатель к названию цели и затем запускаем команду на цель.
Эти команды ограничивают изменения значения по указателю,
пока другой не будет ограничен взамен этого или вызов примет в качестве указателя 0.
Параметр GL_ARRAY_BUFFER означает, что буфер будет хранить массив вершин.
Можно указать другой параметр GL_ELEMENT_ARRAY_BUFFER он показывает, что индексы вершин хранятся в другом буфере.
____
`glBufferData(GL_ARRAY_BUFFER, sizeof(Vertices), Vertices, GL_STATIC_DRAW);` - После связывания нашего объекта, мы наполняем его данными.
Вызов выше принимает название цели (такое же как и при привязывании), размер данных в байтах, адрес массива вершин, и флаг,
который обозначает использование паттернов для этих данных.
Так как мы не собираемся изменять значения буфера, указываем GL_STATIC_DRAW. Его противоположность GL_DYNAMIC_DRAW.
____
`glEnableVertexAttribArray(0);` - индексацию атрибутов каждой вершины
____
`glBindBuffer(GL_ARRAY_BUFFER, VBO);` - мы обратно привязываем наш буфер, приготавливая его для отрисовки
____
`glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, 0);` - Этот вызов говорит конвейеру как воспринимать данные внутри буфера.

Первый параметр указывает на индекс атрибута. В нашем случае мы знаем, что это 0 по-умолчанию,
но когда мы начнем использовать шейдеры, нужно будет указать либо явно указать индексы, либо запросы на них.

Второй параметр - это количество компонентов в атрибуте (3 для X, Y и Z).

Третий параметр - тип данных для каждого компонента.

Четвертый - хотим ли мы нормализовать атрибуты перед использованием в конвейере. В нашем случае мы хотим, что бы данные передавались не именными.

Пятый параметр (названный "шаг") является числом байтов между 2 экземплярами атрибута.
Поскольку мы храним только один атрибут (например, буфер хранит только координаты вершины) и данные плотно упакованы,
мы передаем нулевое значение. Если мы имеем массив структур,
которые содержат координаты вершины и нормали (а это вектор из 3-х чисел типа float)
мы передадим размер структуры в байтах (6 * 4 = 24).

Шестой параметр - полезен в случае с предыдущим примером. Нам нужно, указать смещение в структуре, которую получит наш конвейер.
Тогда в случае структуры с координатами позиции и нормалями смещение по позиции равно 0, а смещение нормали 12.
____
`glDrawArrays(GL_POINTS, 0, 1);` - вызов функции отрисовки. Она порядковая, поэтому мы не использовали буфер индексов.
Мы указали тип как точку, это значит, что каждая вершина - одна точка. 
Следующий параметр это индекс первой вершины для отрисовки. В нашем случае мы хотим брать вершины с начала буфера,
поэтому мы указали 0. Это позволяет хранить несколько моделей в одном буфере и затем указывать одну,
задав её начальное положение. 
Последний параметр - количество вершин для отрисовки.
____
`glDrawArrays(GL_TRIANGLES, 0, 3);` - есть 2 категории отрисовки: порядковая и индексированная. Порядковая проще. 
GPU обходит буфер вершин проходя через вершины одна за другой и интерпретирует их в соответствии с типом,
указанном в вызове функции. Например, если указать GL_TRIANGLES, то вершины 0-2 станут первым треугольником, 3-5 вторым и т.д. 
Если вы хотите использовать одну вершину более чем в одном треугольнике, то необходимо дублировать её в буфере вершин,
а это пустая трата памяти.

Индексированная отрисовка гораздо сложнее и для её использования приходится вводить дополнительные буферы.
Буфер индексов хранит номера вершин в вершинном буфере. GPU сканирует буфер индексов и аналогично описанному выше вершины
с индексами 0-2 становятся первым треугольником и т.д. Если необходимо использовать некоторые вершины в 2 треугольниках 
необходимо просто указать индекс дважды в буфере индексов. Буферу вершин необходимо только хранить одну копию.
Индексированная отрисовка более подходящая для игр, поскольку большинство 3D моделей состоят из треугольников,
представляющих некоторую поверхность (кожа лица, стена замка и т.д.) с большим количество общих вершин. 
____
`glDisableVertexAttribArray(0);` - отключение атрибута вершины
____





